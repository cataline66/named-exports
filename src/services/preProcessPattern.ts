import fs from 'fs'
import isDirectory from '../utils/isDirectory'
import normalizePath from '../utils/normalizePath'
import { Pattern } from '../types'

export default (pattern: Pattern) => {
  pattern.basePath = pattern.basePath ? normalizePath(pattern.basePath) : ''

  pattern.paths = pattern.paths
    ? pattern.paths.map((path) => normalizePath(path))
    : []

  pattern.ignore =
    pattern.ignore &&
    pattern.ignore.length > 0 &&
    !pattern.ignore.includes('.DS_Store')
      ? [...pattern.ignore, '.DS_Store']
      : ['.DS_Store']

  pattern.includeFolders =
    typeof pattern.includeFolders !== 'undefined'
      ? pattern.includeFolders
      : false

  pattern.output = pattern.output ? pattern.output : {}

  pattern.output.filename = pattern.output.filename
    ? pattern.output.filename
    : 'index.js'

  pattern.output.comment =
    typeof pattern.output.comment === 'string'
      ? `// ${pattern.output.comment
          .split('//')
          .filter((x) => x)
          .join('')
          .trim()}`
      : pattern.output.comment === true
      ? '// automatically generated by the Named Exports plugin'
      : false

  pattern.output.semi =
    typeof pattern.output.semi !== 'undefined' ? pattern.output.semi : false

  pattern.output.singleQuote =
    typeof pattern.output.singleQuote !== 'undefined'
      ? pattern.output.singleQuote
      : true

  pattern.output.singleQuote =
    typeof pattern.output.singleQuote !== 'undefined'
      ? pattern.output.singleQuote
      : true

  pattern.output.finalNewLine =
    typeof pattern.output.finalNewLine !== 'undefined'
      ? pattern.output.finalNewLine
      : true

  pattern.pathsJoined = []
  pattern.pathsToExport = []
  pattern.pathsToWatch = []

  if (pattern.basePath && !isDirectory(pattern.basePath)) {
    throw new Error('base path does not exist')
  }

  if (pattern.paths.length <= 0) {
    throw new Error('paths are required')
  }

  if (!/^[a-zA-Z\.]+\.(ts|js)$/.test(pattern.output.filename)) {
    throw new Error('invalid output filename')
  }

  pattern.pathsJoined = !pattern.basePath
    ? pattern.paths
    : pattern.paths.map((path) => {
        return `${pattern.basePath}/${path}`
      })

  pattern.pathsJoined.forEach((path) => {
    if (isDirectory(path)) {
      if (pattern.pathsToExport) pattern.pathsToExport.push(path)
      if (pattern.pathsToWatch) pattern.pathsToWatch.push(path)
    } else if (path.slice(-3) === '/**') {
      const deepPath = path.slice(0, -3)

      if (isDirectory(deepPath)) {
        if (pattern.pathsToWatch) pattern.pathsToWatch.push(deepPath)

        fs.readdirSync(deepPath).forEach((directory) => {
          const subdirectory = `${deepPath}/${directory}`

          if (isDirectory(subdirectory)) {
            if (pattern.pathsToExport) pattern.pathsToExport.push(subdirectory)
            if (pattern.pathsToWatch) pattern.pathsToWatch.push(subdirectory)
          }
        })
      } else {
        throw new Error(`${path} it's an invalid path`)
      }
    } else {
      throw new Error(`${path} it's an invalid paths`)
    }
  })

  return pattern
}
